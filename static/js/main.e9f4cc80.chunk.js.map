{"version":3,"sources":["sentenceCase.ts","formatEvidences.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["CAMEL_CASE_REGEX","CONNECTOR_CHARACTERS","sentenceCase","result","input","replace","_","toLower","upperFirst","LINE_TYPE","MARKDOWN_IMAGE_REGEX","GROUPABLE_IMAGE_NAME_REGEX","App","useState","content","setContent","format","useCallback","formattedContent","textBlob","lines","split","map","line","imageRegexMatch","match","text","type","TEXT","imageName","imageLink","imageTag","groupableImageRegexMatch","IMAGE","group","imageIndex","GROUPABLE_IMAGE","meta","value","textLines","reject","groupableImageLines","filter","orderBy","groupBy","flatMap","imageLines","groupName","join","formatEvidences","navigator","clipboard","writeText","style","margin","height","width","onChange","event","target","display","onClick","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"2NAEMA,EAAmB,mBACnBC,EAAuB,SAEd,SAASC,IAA0B,IAC5CC,EAD+BC,EAAY,uDAAJ,GAkB3C,OARAD,GAHAA,GAHAA,EAAM,UAAMC,IAGIC,QAAQL,EAAkB,UAG1BK,QAAQJ,EAAsB,KAG9CE,EAASG,IAAEC,QAAQJ,GAGnBA,EAASG,IAAEE,WAAWL,GCjBxB,IAQKM,EARCC,EAAuB,oBAMvBC,EAA6B,qB,SAE9BF,O,eAAAA,I,iBAAAA,I,sCAAAA,M,gBCkBUG,MA3Bf,WAAgB,IAAD,EACiBC,mBAAS,IAD1B,mBACNC,EADM,KACGC,EADH,KAGPC,EAASC,uBAAY,WACzB,IAAMC,EDWK,SAAyBC,GACtC,IAAMC,EAAQd,IAAEa,GACbE,MAAM,MACNC,KAAI,SAAAC,GACH,IAAMC,EAAkBD,EAAKE,MAAMf,GAEnC,IAAKc,EAAiB,MAAO,CAAEE,KAAMH,EAAMI,KAAMlB,EAAUmB,MAHhD,kBAKsBJ,EALtB,GAKFK,EALE,KAKSC,EALT,KAMLC,EAAQ,oBAAgBD,EAAhB,kBAAmCD,EAAnC,mBAERG,EAA2BT,EAAKE,MAAMd,GAE5C,IAAKqB,EACH,MAAO,CAAEN,KAAMK,EAAUJ,KAAMlB,EAAUwB,OAXhC,kBAamBD,EAbnB,GAaFE,EAbE,KAaKC,EAbL,KAeX,MAAO,CACLT,KAAMK,EACNJ,KAAMlB,EAAU2B,gBAChBC,KAAM,CAAEH,QAAOC,YAAaA,OAG/BG,QAEGC,EAAYjC,IAAEkC,OAAOpB,EAAO,CAAEO,KAAMlB,EAAU2B,kBAC9CK,EAAsBnC,IAAEc,GAC3BsB,OAAO,CACNf,KAAMlB,EAAU2B,kBAEjBO,QAAQ,cACRA,QAAQ,mBACRC,QAAQ,cACRC,SAAQ,SAACC,EAAYC,GACpB,MAAM,CAEJ,CAAErB,KAAM,GAAIC,KAAMlB,EAAUmB,MAC5B,CAAEF,KAAK,MAAD,OAAQxB,EAAa6C,IAAcpB,KAAMlB,EAAUmB,MACzD,CAAEF,KAAM,GAAIC,KAAMlB,EAAUmB,OAJ9B,mBAOKkB,OAGNR,QAEH,OAAOhC,IAAE,GAAD,mBAAKiC,GAAL,YAAmBE,KACxBnB,IAAI,QACJ0B,KAAK,MC5DmBC,CAAgBnC,GAEzCC,EAAWG,GACXgC,UAAUC,UAAUC,UAAUlC,KAC7B,CAACJ,EAASC,IAEb,OACE,sBAAKsC,MAAO,CAAEC,OAAQ,KAAtB,UACE,qDAEA,0BACED,MAAO,CAAEE,OAAQ,IAAKC,MAAO,KAC7BlB,MAAOxB,EACP2C,SAAU,SAAAC,GAAK,OAAI3C,EAAW2C,EAAMC,OAAOrB,UAG7C,wBAAQe,MAAO,CAAEO,QAAS,SAAWC,QAAS7C,EAA9C,+BCTS8C,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.e9f4cc80.chunk.js","sourcesContent":["import _ from \"lodash\";\n\nconst CAMEL_CASE_REGEX = /([a-z]+)([A-Z])/g;\nconst CONNECTOR_CHARACTERS = /[-_.]/g;\n\nexport default function sentenceCase(input = \"\") {\n  let result;\n\n  // Stringify the input\n  result = `${input}`;\n\n  // Add spaces for camelCases\n  result = result.replace(CAMEL_CASE_REGEX, \"$1 $2\");\n\n  // Replace connector characters with spaces\n  result = result.replace(CONNECTOR_CHARACTERS, \" \");\n\n  // Lower case everything\n  result = _.toLower(result);\n\n  // Capitalise first letter\n  result = _.upperFirst(result);\n\n  return result;\n}\n","import _ from \"lodash\";\n\nimport sentenceCase from \"./sentenceCase\";\n\nconst MARKDOWN_IMAGE_REGEX = /!\\[(.+)\\]\\((.+)\\)/;\n\n// GroupableImage: Camel case with - and number\n// e.g. addCtaToWithdrawalNotAvailableScreen-0\n//      addCtaToWithdrawalNotAvailableScreen-1\n// These 2 will be grouped together and have a section assigned for them\nconst GROUPABLE_IMAGE_NAME_REGEX = /([a-zA-Z]+)-(\\d+)/;\n\nenum LINE_TYPE {\n  TEXT,\n  IMAGE,\n  GROUPABLE_IMAGE\n}\n\nexport default function formatEvidences(textBlob: string) {\n  const lines = _(textBlob)\n    .split(\"\\n\")\n    .map(line => {\n      const imageRegexMatch = line.match(MARKDOWN_IMAGE_REGEX);\n      // Not a markdown image, return them right away\n      if (!imageRegexMatch) return { text: line, type: LINE_TYPE.TEXT };\n\n      const [, imageName, imageLink] = imageRegexMatch;\n      const imageTag = `<img src=\"${imageLink}\" alt=\"${imageName}\" width=\"250\"/>`;\n\n      const groupableImageRegexMatch = line.match(GROUPABLE_IMAGE_NAME_REGEX);\n      // Not a groupable image, return them right away\n      if (!groupableImageRegexMatch)\n        return { text: imageTag, type: LINE_TYPE.IMAGE };\n\n      const [, group, imageIndex] = groupableImageRegexMatch;\n\n      return {\n        text: imageTag,\n        type: LINE_TYPE.GROUPABLE_IMAGE,\n        meta: { group, imageIndex: +imageIndex }\n      };\n    })\n    .value();\n\n  const textLines = _.reject(lines, { type: LINE_TYPE.GROUPABLE_IMAGE });\n  const groupableImageLines = _(lines)\n    .filter({\n      type: LINE_TYPE.GROUPABLE_IMAGE\n    })\n    .orderBy(\"meta.group\")\n    .orderBy(\"meta.imageIndex\")\n    .groupBy(\"meta.group\")\n    .flatMap((imageLines, groupName) => {\n      return [\n        // Group header and separator\n        { text: \"\", type: LINE_TYPE.TEXT },\n        { text: `## ${sentenceCase(groupName)}`, type: LINE_TYPE.TEXT },\n        { text: \"\", type: LINE_TYPE.TEXT },\n\n        // Grouped images\n        ...imageLines\n      ];\n    })\n    .value();\n\n  return _([...textLines, ...groupableImageLines])\n    .map(\"text\")\n    .join(\"\\n\");\n}\n","import React, { useCallback, useState } from \"react\";\nimport formatEvidences from \"./formatEvidences\";\n\nfunction App() {\n  const [content, setContent] = useState(\"\");\n\n  const format = useCallback(() => {\n    const formattedContent = formatEvidences(content);\n\n    setContent(formattedContent);\n    navigator.clipboard.writeText(formattedContent);\n  }, [content, setContent]);\n\n  return (\n    <div style={{ margin: 100 }}>\n      <h1>Evidence formatters</h1>\n\n      <textarea\n        style={{ height: 300, width: 400 }}\n        value={content}\n        onChange={event => setContent(event.target.value)}\n      />\n\n      <button style={{ display: \"block\" }} onClick={format}>\n        Format & copy\n      </button>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}